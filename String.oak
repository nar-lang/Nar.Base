module Oak.Core.String

import "./Basics.oak" exposing *
import "./Bitwise.oak"
import "./Char.oak" exposing (Char)
import "./List.oak" exposing (List, (::))
import "./Maybe.oak" exposing (Maybe)
import "./Result.oak" exposing (Result)

infix (<>): (right 5) = append

alias extern String

def isEmpty(string: String): Bool =
  string == ""

def extern length(s: String): Int

def extern reverse(s: String): String

def repeat(n: Int, chunk: String): String =
  repeatHelp(n, chunk, "")

def hidden repeatHelp(n: Int, chunk: String, result: String): String =
  if n <= 0 then
    result
  else
    repeatHelp(Bitwise.shiftRightBy(1, n), chunk <> chunk) <|
      if Bitwise.and(n, 1) == 0 then result else result <> chunk

def replace(before: String, after: String, string: String): String =
  join(after, split(before, string))


// BUILDING AND SPLITTING

def extern append(a: String, b: String): String

def concat(strings: List[String]): String =
  join("", strings)

def extern split(sep: String, string: String): List[String]

def extern join(sep: String, strings: List[String]): String

def extern words(string: String): List[String]

def extern lines(string: String): List[String]

// SUBSTRINGS

def extern slice(begin: Int, end: Int, s: String): String

def left(n: Int, string: String): String =
  if n < 1 then
    ""
  else
    slice (0, n, string)

def right(n: Int, string: String): String =
  if n < 1 then
    ""
  else
    slice(-n, length(string), string)

def dropLeft(n: Int, string: String): String =
  if n < 1 then
    string
  else
    slice(n, length(string), string)

def dropRight(n: Int, string: String): String =
  if n < 1 then
    string
  else
    slice(0, -n, string)

// DETECT SUBSTRINGS

def extern contains(sub: String, string: String): Bool

def extern startsWith(sub: String, string: String): Bool

def extern endsWith(sub: String, string: String): Bool

def extern indices(sub: String, string: String): List[Int]

// FORMATTING

def extern toUpper(s: String): String

def extern toLower(s: String): String

def pad(n: Int, char: Char, string: String): String =
  let
    half = Basics.toFloat((n - length(string)) / 2.0)
  in
    repeat(ceiling(half), fromChar(char) <> string <> repeat(floor(half), fromChar(char)))

def padLeft(n: Int, char: Char, string: String): String =
  repeat(n - length(string), fromChar(char) <> string)

def padRight(n: Int, char: Char, string: String): String =
  string <> repeat(n - length(string), fromChar(char))

def extern trim(s: String): String

def extern trimLeft(s: String): String

def extern trimRight(s: String): String

// INT CONVERSIONS

def extern toInt(s: String): Maybe[Int]

def extern fromInt(n: Int): String

// FLOAT CONVERSIONS

def extern toFloat(s: String): Maybe[Float]

def extern fromFloat(n: Float): String

// LIST CONVERSIONS

def toList(string: String): List[Char] =
  foldr((::), [], string)

def extern fromList(chars: List[Char]): String

// CHAR CONVERSIONS

def fromChar(char: Char): String =
  cons(char, "")

def extern cons(c: Char, s: String): String

def extern uncons(s: String): Maybe[( Char, String )]

// HIGHER-ORDER FUNCTIONS

def extern map(f: (Char):Char, s: String): String

def extern filter(f: (Char): Bool, s: String): String

def extern foldl(f: (Char,b):b, acc: b, s: String): b

def extern foldr(f: (Char,b):b, acc: b, s: String): b

def extern any(f: (Char): Bool, s: String): Bool

def extern all(f: (Char): Bool, s: String): Bool
