module Basics

def (<|): (right 0) = apL
def (|>): (left  0) = apR
def (||): (right 2) = or
def (&&): (right 3) = and
def (==): (non   4) = eq
def (/=): (non   4) = neq
def (<) : (non   4) = lt
def (>) : (non   4) = gt
def (<=): (non   4) = le
def (>=): (non   4) = ge
def (+) : (left  6) = add
def (-) : (left  6) = sub
def (*) : (left  7) = mul
def (/) : (left  7) = fdiv
def (//): (left  7) = idiv
def (^) : (right 8) = pow
def (<<): (left  9) = composeL
def (>>): (right 9) = composeR

type Int = extern

type Float = extern

def add[N: Number]: (N -> N -> N) = extern

def sub[N: Number]: (N -> N -> N) = extern

def mul[N: Number]: (N -> N -> N) = extern

def fdiv: (Float -> Float -> Float) = extern

def idiv: (Int -> Int -> Int) = extern

def neg[N: Number]: (N -> N) = extern

-- INT TO FLOAT / FLOAT TO INT

def toFloat: (Int -> Float) = extern

def round: (Float -> Int) = extern

def floor: (Float -> Int) = extern

def ceiling: (Float -> Int) = extern

def truncate: (Float -> Int) = extern

-- EQUALITY

def eq[Eq: Equatable]: (Eq -> Eq -> Bool) = extern

def neq[Eq: Equatable]: (Eq -> Eq -> Bool) = extern

-- COMPARISONS

def lt[Cmp: Comparable]: (Cmp -> Cmp -> Bool) = extern

def gt[Cmp: Comparable]: (Cmp -> Cmp -> Bool) = extern

def le[Cmp: Comparable]: (Cmp -> Cmp -> Bool) = extern

def ge[Cmp: Comparable]: (Cmp -> Cmp -> Bool) = extern

def min[Cmp: Comparable]: (x: Cmp -> y: Cmp -> Cmp) =
  if lt x y then x else y

def max[Cmp: Comparable]: (x: Cmp -> y: Cmp -> Cmp) =
  if gt x y then x else y

def compare[Cmp: Comparable]: (Cmp -> Cmp -> Order) = extern

type Order =
  | LT
  | EQ
  | GT

-- BOOLEANS

type Bool =
  | True
  | False

def not: (Bool -> Bool) = extern

def and: (Bool -> Bool -> Bool) = extern

def or: (Bool -> Bool -> Bool) = extern

def xor: (Bool -> Bool -> Bool) = extern

-- FUNCTION HELPERS

def composeL[A, B, C]: (g: (B->C) -> f: (A->B) -> x: A -> C) =
  g (f x)

def composeR[A, B, C]: (f: (A->B) -> g: (B->C) -> x: A -> C) =
  g (f x)

def apR[A, B]: (x: A -> f: (A->B) -> B) =
  f x

def apL[A, B]: (f: (A->B) -> x: A -> B) =
  f x

def identity[A]: (x: A -> A) =
  x

def always[A, A]: (x: A -> _: B -> A) =
  x

def pi : Float = 3.1415

{--
compiler stack overflow

type Never =
  | JustOneMore Never

def never[a]: (x: Never -> a) =
  select x
    case JustOneMore n -> never[a] n
--}
