module String

import Basics exposing *
import Bitwise
import Char exposing (Char)
import List exposing (List, (::))
import Maybe exposing (Maybe)
import Result exposing (Result)

def (<>): (right 5) = append

type String = extern

def isEmpty: (string: String -> Bool) =
  string == ""

def length: (String -> Int) = extern

def reverse: (String -> String) = extern

def repeat: (n: Int -> chunk: String -> String) =
  repeatHelp n chunk ""

hidden def repeatHelp: (n: Int -> chunk: String -> result: String -> String) =
  if n <= 0 then
    result
  else
    repeatHelp (Bitwise.shiftRightBy 1 n) (chunk <> chunk) <|
      if Bitwise.and n 1 == 0 then result else result <> chunk

def replace: (before: String -> after: String -> string: String -> String) =
  join after (split before string)


-- BUILDING AND SPLITTING

def append: (String -> String -> String) = extern

def concat: (strings: List[String] -> String) =
  join "" strings

def split: (sep: String -> string: String -> List[String]) = extern

def join: (String -> List[String] -> String) = extern

def words: (String -> List[String]) = extern

def lines: (String -> List[String]) = extern

-- SUBSTRINGS

def slice: (begin: Int -> end: Int -> s: String -> String) = extern

def left: (n: Int -> string: String -> String) =
  if n < 1 then
    ""
  else
    slice 0 n string

def right: (n: Int -> string: String -> String) =
  if n < 1 then
    ""
  else
    slice -n (length string) string

def dropLeft: (n: Int -> string: String -> String) =
  if n < 1 then
    string
  else
    slice n (length string) string

def dropRight: (n: Int -> string: String -> String) =
  if n < 1 then
    string
  else
    slice 0 -n string

-- DETECT SUBSTRINGS

def contains: (sub: String -> s: String -> Bool) = extern

def startsWith: (String -> String -> Bool) = extern

def endsWith: (String -> String -> Bool) = extern

def indices: (String -> String -> List[Int]) = extern

-- FORMATTING

def toUpper: (String -> String) = extern

def toLower: (String -> String) = extern

def pad: (n: Int -> char: Char -> string: String -> String) =
  let
    half: Float = Basics.toFloat (n - length string) / 2.0
  in
    repeat (ceiling half) (fromChar char) <> string <> repeat (floor half) (fromChar char)

def padLeft: (n: Int -> char: Char -> string: String -> String) =
  repeat (n - length string) (fromChar char) <> string

def padRight: (n: Int -> char: Char -> string: String -> String) =
  string <> repeat (n - length string) (fromChar char)

def trim: (String -> String) = extern

def trimLeft: (String -> String) = extern

def trimRight: (String -> String) = extern

-- INT CONVERSIONS

def toInt: (String -> Maybe[Int]) = extern

def fromInt: (Int -> String) = extern

-- FLOAT CONVERSIONS

def toFloat: (String -> Maybe[Float]) = extern

def fromFloat: (Float -> String) = extern

-- LIST CONVERSIONS

def toList: (string: String -> List[Char]) =
  foldr (::) [] string

def fromList: (List[Char] -> String) = extern

-- CHAR CONVERSIONS

def fromChar: (char: Char -> String) =
  cons char ""

def cons: (Char -> String -> String) = extern

def uncons: (String -> Maybe[{Char, String}]) = extern

-- HIGHER-ORDER FUNCTIONS

def map: ((Char -> Char) -> String -> String) = extern

def filter: ((Char -> Bool) -> String -> String) = extern

def foldl[b: any]: ((Char -> b -> b) -> b -> String -> b) = extern

def foldr[b: any]: ((Char -> b -> b) -> b -> String -> b) = extern

def any: ((Char -> Bool) -> String -> Bool) = extern

def all: ((Char -> Bool) -> String -> Bool) = extern
