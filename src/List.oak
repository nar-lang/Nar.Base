module List

import Basics exposing *
import Maybe exposing (Maybe)

def (++): (right 5) = append
def (::): (right 5) = cons

type List[T] = extern

def singleton[A]: (value: A -> List[A]) =
  [value]

def repeat[A]: (n: Int -> value: A -> List[A]) =
  repeatHelp [] n value

hidden def repeatHelp[A]: (result: List[A] -> n: Int -> value: A -> List[A]) =
  if n <= 0 then
    result
  else
    repeatHelp (cons value result) (n-1) value

def range: (lo: Int ->  hi: Int -> List[Int]) =
  rangeHelp lo hi []

hidden def rangeHelp: (lo: Int -> hi: Int -> list: List[Int] -> List[Int]) =
  if lo <= hi then
    rangeHelp lo (hi - 1) (cons hi list)
  else
    list

def cons[A]: (A -> List[A] -> List[A]) = extern

def map[A,B]: (f: (A -> B) -> xs: List[A] -> List[B]) =
  let
    lambda: (x: A -> acc: List[B] -> List[B]) = cons (f x) acc
  in
    foldr lambda [] xs
    --foldr (\x acc -> cons (f x) acc) [] xs

def indexedMap[A,B]: (f: (Int -> A -> B) -> xs: List[A] -> List[B]) =
  map2 f (range 0 (length xs - 1)) xs

def foldl[A,B]: (func: (A -> B -> B) -> acc: B -> list: List[A] -> B) =
  select list
    case [] ->
      acc
    case x :: xs ->
      foldl func (func x acc) xs

def foldr[A,B]: (fn: (A -> B -> B) -> acc: B -> ls: List[A] -> B) =
    foldrHelper fn acc 0 ls

hidden def foldrHelper[A, B]: (fn: (A -> B -> B) -> acc: B -> ctr: Int -> ls: List[A] -> B) =
    select ls
        case [] ->
            acc
        case a :: r1 ->
            select r1
                case [] ->
                    fn a acc
                case b :: r2 ->
                    select r2
                        case [] ->
                            fn a (fn b acc)
                        case c :: r3 ->
                            select r3
                                case [] ->
                                    fn a (fn b (fn c acc))
                                case d :: r4 ->
                                    let
                                        res: B =
                                            if ctr > 500 then
                                                foldl fn acc (reverse r4)
                                            else
                                                foldrHelper fn acc (ctr + 1) r4
                                    in
                                        fn a (fn b (fn c (fn d res)))

def filter[A]: (isGood: (A -> Bool) -> list: List[A] -> List[A]) =
  let
    lambda : (x: A -> xs: List[A] -> List[A]) = if isGood x then cons x xs else xs
  in
    foldr lambda [] list
  --foldr (\x xs -> if isGood x then cons x xs else xs) [] list

def filterMap[A, B]: (f: (A -> Maybe[B]) -> xs: List[A] -> List[B]) =
  foldr (maybeCons f) [] xs

def maybeCons[A, B]: (f: (A -> Maybe[B]) -> mx: A -> xs: List[B] -> List[B]) =
  select f mx
    case Just x ->
      cons x xs
    case Nothing ->
      xs

def length[A]: (xs: List[A] -> Int) =
  let
    lambda : (_: A -> i: Int -> Int) = i + 1
  in
    foldl lambda 0 xs

def reverse[A]: (list: List[A] -> List[A]) =
  foldl cons [] list

def member[A: Equatable]: (x: A -> xs: List[A] -> Bool) =
  let
    lambda : (y: A -> Bool) = x == y
  in
    any lambda xs
  --any (\a -> a == x) xs

def all[A]: (isOkay: (A -> Bool) -> list: List[A] -> Bool) =
  not (any (not << isOkay) list)

def any[A]: (isOkay: (A -> Bool) -> list: List[A] -> Bool) =
  select list
    case [] ->
      False
    case x :: xs ->
      -- note: (isOkay x || any isOkay xs) would not get TCO
      if isOkay x then
        True
      else
        any isOkay xs

def maximum[A: Comparable]: (list: List[A] -> Maybe[A]) =
  select list
    case x :: xs ->
      Just (foldl max x xs)
    case _ ->
      Nothing

def minimum[A: Comparable]: (list: List[A] -> Maybe[A]) =
  select list
    case x :: xs ->
      Just (foldl min x xs)
    case _ ->
      Nothing

def sum[A: Number]: (numbers: List[A] -> A)=
  foldl (+) 0 numbers

def product[A: Number]: (numbers: List[A] -> A) =
  foldl (*) 1 numbers

def append[A]: (xs: List[A] -> ys: List[A] -> List[A]) =
  select ys
    case [] ->
      xs
    case _ ->
      foldr cons ys xs

def concat[A]: (lists: List[List[A]] -> List[A]) =
  foldr append [] lists

def concatMap[A, B]: (f: (A -> List[B]) -> list: List[A] -> List[B]) =
  concat (map f list)

def intersperse[A]: (sep: A -> xs: List[A] -> List[A]) =
  select xs
    case [] ->
      []
    case hd :: tl ->
      let
        step: (x: A -> rest: List[A] -> List[A]) = cons sep (cons x rest);
        spersed: List[A] = foldr step [] tl
      in
        cons hd spersed

def map2[A, B, R]: (
  (A -> B -> R) ->
  List[A] -> List[B] -> List[R]
) = extern

def map3[A, B, C, R]: ((A -> B -> C -> R) -> List[A] -> List[B] -> List[C] -> List[R]) = extern

def map4[A, B, C, D, R]: (
  (A -> B -> C -> D -> R) ->
  List[A] -> List[B] -> List[C] -> List[D] -> List[R]
) = extern

def map5[A, B, C, D, E, R]: (
  (A -> B -> C -> D -> E -> R) ->
  List[A] -> List[B] -> List[C] -> List[D] -> List[E] -> List[R]
) = extern

def sort[A: Comparable]: (xs: List[A] -> List[A]) =
  sortBy identity xs

def sortBy[A, B: Comparable]: ((A -> B) -> List[A] -> List[A]) = extern

def sortWith[A]: ((A -> A -> Order) -> List[A] -> List[A]) = extern

def isEmpty[A]: (xs: List[A] -> Bool) =
  select xs
    case [] -> True
    case _ -> False

def head[A]: (list: List[A] -> Maybe[A]) =
  select list
    case x :: _ -> Just x
    case [] -> Nothing

def tail[A]: (list: List[A] -> Maybe[List[A]]) =
  select list
    case x :: xs -> Just xs
    case [] -> Nothing

def take[A]: (n: Int -> list: List[A] -> List[A]) =
  takeFast 0 n list

hidden def takeFast[A]: (ctr: Int -> n: Int -> list: List[A] -> List[A]) =
  if n <= 0 then
    []
  else
    select { n, list }
      case { _, [] } ->
        list
      case { 1, x :: _ } ->
        [ x ]
      case { 2, x :: y :: _ } ->
        [ x, y ]
      case { 3, x :: y :: z :: _ } ->
        [ x, y, z ]
      case { _, x :: y :: z :: w :: tl } ->
        if ctr > 1000 then
          cons x (cons y (cons z (cons w (takeTailRec (n - 4) tl))))
        else
          cons x (cons y (cons z (cons w (takeFast (ctr + 1) (n - 4) tl))))
      case _ ->
        list

hidden def takeTailRec[A]: (n: Int -> list: List[A] -> List[A]) =
  reverse (takeReverse n list [])

hidden def takeReverse[A]: (n: Int -> list: List[A] -> kept: List[A] -> List[A]) =
  if n <= 0 then
    kept
  else
    select list
      case [] ->
        kept
      case x :: xs ->
        takeReverse (n - 1) xs (cons x kept)

def drop[A]: (n: Int -> list:List[A] -> List[A]) =
  if n <= 0 then
    list
  else
    select list
      case [] ->
        list
      case x :: xs ->
        drop (n-1) xs

def partition[A]: (pred: (A -> Bool) -> list: List[A] -> {List[A], List[A]}) =
  let
    step : (x: A -> {trues, falses}: {List[A], List[A]} -> {List[A], List[A]}) =
      if pred x then
        {cons x trues, falses}
      else
        {trues, cons x falses}
  in
    foldr step {[],[]} list

def unzip[A,B]: (pairs: List[{A,B}] -> {List[A], List[B]}) =
  let
    step: ({x, y}: {A, B} -> {xs, ys}: {List[A], List[B]} -> {List[A], List[B]}) =
      {cons x xs, cons y ys}
  in
    foldr step {[], []} pairs
