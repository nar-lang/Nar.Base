module Oak.Core.Set

import Oak.Core.Basics exposing (Bool, Int)
import Oak.Core.Dict exposing (Dict)
import Oak.Core.List exposing (List, (|))
import Oak.Core.Maybe exposing (Maybe)

data Set[t]
  = hidden SetImpl(Dict[t, ()])

def empty: Set[a] =
  SetImpl(Dict.empty)

def singleton(key: cmp): Set[cmp] =
  SetImpl(Dict.singleton(key, ()))

def insert(key: cmp, (SetImpl(dict)): Set[cmp]): Set[cmp] =
  SetImpl(Dict.insert(key, (), dict))

def remove(key: cmp, (SetImpl(dict)): Set[cmp]): Set[cmp] =
  SetImpl(Dict.remove(key, dict))

def isEmpty(SetImpl(dict): Set[a]): Bool =
  Dict.isEmpty(dict)

def member(key: cmp, (SetImpl(dict)): Set[cmp]): Bool =
  Dict.member(key, dict)

def size((SetImpl(dict)): Set[a]): Int =
  Dict.size(dict)

def union((SetImpl(dict1)): Set[cmp], (SetImpl(dict2)): Set[cmp]): Set[cmp] =
  SetImpl(Dict.union(dict1, dict2))

def intersect((SetImpl(dict1)): Set[cmp], (SetImpl(dict2)): Set[cmp]): Set[cmp] =
  SetImpl (Dict.intersect(dict1, dict2))

def diff((SetImpl(dict1)): Set[cmp], (SetImpl(dict2)): Set[cmp]): Set[cmp] =
  SetImpl (Dict.diff(dict1, dict2))

def toList((SetImpl(dict)): Set[a]): List[a] =
  Dict.keys(dict)

def fromList(list: List[cmp]): Set[cmp] =
  List.foldl(insert, empty, list)

def foldl(func:(a,b):b, initialState: b, (SetImpl(dict)): Set[a]): b =
  Dict.foldl(\(key, _, state) -> func(key, state), initialState, dict)

def foldr(func:(a,b):b, initialState: b, (SetImpl(dict)): Set[a]): b =
  Dict.foldr(\(key, _, state) -> func(key, state), initialState, dict)

def map(func:(cmp):cmp2, set: Set[cmp]): Set[cmp2] =
  fromList(foldl(\(x, xs) -> func(x) | xs, [], set))

def filter(isGood: (cmp):Bool, (SetImpl(dict)): Set[cmp]): Set[cmp] =
  SetImpl(Dict.filter(\(key, _) -> isGood(key), dict))

def partition(isGood:(cmp):Bool, (SetImpl(dict)): Set[cmp]): (Set[cmp], Set[cmp]) =
  let
    (dict1, dict2) =
      Dict.partition(\(key, _) -> isGood(key), dict)
  in
    (SetImpl(dict1), SetImpl(dict2))
