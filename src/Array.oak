module Oak.Core.Array

import Oak.Core.Basics exposing *
import Oak.Core.Bitwise exposing *
import Oak.Core.Math exposing *
import Oak.Core.List exposing (List, (|))
import Oak.Core.NativeArray exposing (NativeArray)
import Oak.Core.Maybe exposing (Maybe)
import Oak.Core.Tuple

def hidden branchFactor: Int = 32

def hidden shiftStep: Int = ceil(logBase(2, toFloat(branchFactor)))

def bitMask: Int = 0xFFFFFFFF >>> 32 - shiftStep

data Array[a]
  = hidden ArrayImpl(length: Int, startShift: Int, tree: Tree[a], tail: NativeArray[a])

data hidden Node[a]
  = SubTree(Tree[a])
  | Leaf(NativeArray[a])

alias hidden Tree[a] = NativeArray[Node[a]]

def empty: Array[a] = ArrayImpl(0, shiftStep, NativeArray.empty, NativeArray.empty)

def isEmpty(ArrayImpl(len, _, _, _): Array[a]): Bool =
  len == 0

def length(ArrayImpl(len, _, _, _): Array[a]): Bool =
  len

def initialize(len: Int, fn: (Int): a): Array[a] =
  if len <= 0 then
    empty
  else
    let tailLen = remainderBy(branchFactor, len)
    let tail = NativeArray.initialize(tailLen, len - tailLen, fn)
    let initialFromIndex = len - tailLen - branchFactor
    in initializeHelp(fn, initialFromIndex, len, [], tail)

def hidden initializeHelp(
  fn: (Int):a, fromIndex: Int, len: Int, nodeList: List[Node[a]], tail: NativeArray[a]
): Array[a] =
  if fromIndex < 0 then
    builderToArray(False, { tail = tail , nodeList = nodeList , nodeListSize = len })
  else
    let leaf = Leaf <| NativeArray.initialize(branchFactor, fromIndex, fn)
    in initializeHelp(fn, fromIndex - branchFactor, len, leaf | nodeList, tail)

def repeat(n: Int, e: a): Array[a] =
  initialize(n, always(e))

def fromList(list: List[a]): Array[a] =
  select list
    case [] -> empty
    case _ -> fromListHelp(list, [], 0)
  end

def hidden fromListHelp(list: List[a], nodeList: List[Node[a]], nodeListSize: Int): Array[a] =
  let ( jsArray, remainingItems ) = NativeArray.initializeFromList(branchFactor, list)
  in
    if NativeArray.length(jsArray) < branchFactor then
      builderToArray(True, { tail = jsArray , nodeList = nodeList , nodeListSize = nodeListSize })
    else
      fromListHelp(remainingItems, Leaf(jsArray) | nodeList, nodeListSize + 1)

def get(index: Int, ArrayImpl(len, startShift, tree, tail):Array[a]): Maybe[a] =
  if index < 0 || index >= len then
    Nothing
  else if index >= tailIndex(len) then
    Just <| NativeArray.unsafeGet(bitMask & index, tail)
  else
    Just <| getHelp(startShift, index, tree)

def hidden getHelp(shift: Int, index: Int, tree: Tree[a]): a =
  let pos = bitMask & (index >>> shift)
  in
    select NativeArray.unsafeGet(pos, tree)
      case SubTree(subTree) -> getHelp(shift - shiftStep, index, subTree)
      case Leaf(values) -> NativeArray.unsafeGet(bitMask & index, values)
    end

def hidden tailIndex(len: Int): Int =
    len |> shiftRightZfBy(5) |> shiftLeftBy(5)

def set(index: Int, value: a, (ArrayImpl(len, startShift, tree, tail) as array): Array[a]): Array[a] =
  if index < 0 || index >= len then
    array
  else if index >= tailIndex(len) then
    ArrayImpl(len, startShift, tree, NativeArray.unsafeSet(bitMask & index, value, tail))
  else
    ArrayImpl(len, startShift, setHelp(startShift, index, value, tree), tail)

def hidden setHelp(shift: Int, index: Int, value: a, tree: Tree[a]): Tree[a] =
  let pos =  bitMask & (index >>> shift)
  in
    select NativeArray.unsafeGet(pos, tree)
      case SubTree(subTree) ->
        let newSub = setHelp(shift - shiftStep, index, value, subTree)
        in NativeArray.unsafeSet(pos, SubTree(newSub), tree)
      case Leaf(values) ->
        let newLeaf = NativeArray.unsafeSet(bitMask & index, value, values)
        in NativeArray.unsafeSet(pos, Leaf(newLeaf), tree)
    end

def push(a: a, (ArrayImpl(_, _, _, tail) as array): Array[a]): Array[a] =
    unsafeReplaceTail(NativeArray.push(a, tail), array)

def unsafeReplaceTail(newTail: NativeArray[a], ArrayImpl(len, startShift, tree, tail): Array[a]): Array[a] =
  let originalTailLen = NativeArray.length(tail)
  let newTailLen = NativeArray.length(newTail)
  let newArrayLen = len + (newTailLen - originalTailLen)
  in
    if newTailLen == branchFactor then
      let overflow = (newArrayLen >>> shiftStep) > (1 << startShift)
      in
        if overflow then
          let newShift = startShift + shiftStep
          let newTree = NativeArray.singleton(SubTree(tree)) |> insertTailInTree(newShift, len, newTail)
          in ArrayImpl(newArrayLen, newShift, newTree, NativeArray.empty)
        else
          ArrayImpl(newArrayLen, startShift, insertTailInTree(startShift, len, newTail, tree), NativeArray.empty)
    else
      ArrayImpl(newArrayLen, startShift, tree, newTail)

def hidden insertTailInTree(shift: Int, index: Int, tail: NativeArray[a], tree: Tree[a]): Tree[a] =
  let pos = bitMask & (index >>> shift)
  in
    if pos >= NativeArray.length(tree) then
      if shift == 5 then
        NativeArray.push(Leaf(tail), tree)
      else
        let newSub =
          NativeArray.empty
            |> insertTailInTree(shift - shiftStep, index, tail)
            |> SubTree
        in NativeArray.push(newSub, tree)
      else
        let value = NativeArray.unsafeGet(pos, tree)
        in
          select value
            case SubTree(subTree) ->
              let newSub =
                subTree
                  |> insertTailInTree(shift - shiftStep, index, tail)
                  |> SubTree
              in NativeArray.unsafeSet(pos, newSub, tree)

            case Leaf(_) ->
              let newSub =
                NativeArray.singleton(value)
                  |> insertTailInTree(shift - shiftStep, index, tail)
                  |> SubTree
              in NativeArray.unsafeSet(pos, newSub, tree)
          end

def toList(array: Array[a]): List[a] =
  foldr((|), [], array)

def toIndexedList((ArrayImpl(len, _, _, _) as array): Array[a]): List[( Int, a )] =
  let helper(entry, ( index, list )) =
    ( index - 1, ( index, entry ) | list )
  in
    Tuple.second(foldr(helper, ( len - 1, [] ), array))

def foldr(func: (a, b):b, baseCase: b, ArrayImpl(_, _, tree, tail): Array[a]): b =
  let helper(node, acc) =
    select node
      case SubTree(subTree) -> NativeArray.foldr(helper, acc, subTree)
      case Leaf(values) -> NativeArray.foldr(func, acc, values)
    end
  in
    NativeArray.foldr(helper, NativeArray.foldr(func, baseCase, tail), tree)


def foldl(func: (a, b):b, baseCase: b, ArrayImpl(_, _, tree, tail): Array[a]): b =
  let helper(node, acc) =
    select node
      case SubTree (subTree) -> NativeArray.foldl(helper, acc, subTree)
      case Leaf(values) -> NativeArray.foldl(func, acc, values)
    end
  in
    NativeArray.foldl(func, NativeArray.foldl(helper, baseCase, tree), tail)

def filter(isGood: (a): Bool, array: Array[a]): Array[a] =
    fromList(foldr(\(x, xs) -> if isGood(x) then x | xs else xs, [], array))

def map(func: (a): b,  ArrayImpl(len, startShift, tree, tail): Array[a]): Array[b] =
  let helper(node) =
    select node
      case SubTree(subTree) -> SubTree(NativeArray.map(helper, subTree))
      case Leaf(values) -> Leaf(NativeArray.map(func, values))
    end
  in
    ArrayImpl(len, startShift, NativeArray.map(helper, tree), NativeArray.map(func, tail))

def indexedMap(func: (Int, a): b, ArrayImpl(len, _, tree, tail): Array[a]): Array[b] =
  let helper(node, builder) =
    select node
      case SubTree(subTree) -> NativeArray.foldl(helper, builder, subTree)
      case Leaf(leaf) ->
        let offset = builder.nodeListSize * branchFactor
        let mappedLeaf = Leaf(NativeArray.indexedMap(func, offset, leaf))
        in
          { tail = builder.tail
          , nodeList = mappedLeaf | builder.nodeList
          , nodeListSize = builder.nodeListSize + 1
          }
    end
  let initialBuilder =
    { tail = NativeArray.indexedMap(func, tailIndex(len), tail)
    , nodeList = []
    , nodeListSize = 0
    }
  in
    builderToArray(True, NativeArray.foldl(helper, initialBuilder, tree))

def append(
  (ArrayImpl(_, _, _, aTail) as a): Array[a],
  ArrayImpl(bLen, _, bTree, bTail): Array[a]
): Array[a] =
  if bLen <= (branchFactor * 4) then
    let foldHelper(node, array) =
      select(node)
        case SubTree(tree) -> NativeArray.foldl(foldHelper, array, tree)
        case Leaf(leaf) -> appendHelpTree(leaf, array)
      end
    in NativeArray.foldl(foldHelper, a, bTree) |> appendHelpTree(bTail)
  else
    let foldHelper(node, builder) =
      select node
        case SubTree(tree) -> NativeArray.foldl(foldHelper, builder, tree)
        case Leaf(leaf) -> appendHelpBuilder(leaf, builder)
      end
    in NativeArray.foldl(foldHelper, builderFromArray(a), bTree)
      |> appendHelpBuilder(bTail)
      |> builderToArray(True)

def hidden appendHelpTree(toAppend: NativeArray[a], (ArrayImpl(len, _, tree, tail) as array): Array[a]): Array[a] =
  let appended = NativeArray.appendN(branchFactor, tail, toAppend)
  let itemsToAppend = NativeArray.length(toAppend)
  let notAppended = branchFactor - NativeArray.length(tail) - itemsToAppend
  let newArray = unsafeReplaceTail(appended, array)
  in
    if notAppended < 0 then
      let nextTail = NativeArray.slice(notAppended, itemsToAppend, toAppend)
      in unsafeReplaceTail(nextTail, newArray)
    else
      newArray

def hidden appendHelpBuilder(tail: NativeArray[a], builder: Builder[a]): Builder[a] =
  let appended = NativeArray.appendN(branchFactor, builder.tail, tail)
  let tailLen = NativeArray.length(tail)
  let notAppended = branchFactor - NativeArray.length(builder.tail) - tailLen
  in
    if notAppended < 0 then
      { tail = NativeArray.slice(notAppended, tailLen, tail)
      , nodeList = Leaf(appended) | builder.nodeList
      , nodeListSize = builder.nodeListSize + 1
      }
    else if notAppended == 0 then
      { tail = NativeArray.empty
      , nodeList = Leaf(appended) | builder.nodeList
      , nodeListSize = builder.nodeListSize + 1
      }
    else
      { tail = appended
      , nodeList = builder.nodeList
      , nodeListSize = builder.nodeListSize
      }

def slice(from: Int, to: Int, array: Array[a]): Array[a] =
  let correctFrom = translateIndex(from, array)
  let correctTo = translateIndex(to, array)
  in
    if correctFrom > correctTo then
      empty
    else
      array |> sliceRight(correctTo) |> sliceLeft(correctFrom)

def hidden translateIndex(index: Int, ArrayImpl(len, _, _, _): Array[a]): Int =
  let posIndex = if index < 0 then len + index else index
  in
    if posIndex < 0 then
      0
    else if posIndex > len then
      len
    else
      posIndex

def hidden sliceRight(end: Int, (ArrayImpl(len, startShift, tree, tail) as array): Array[a]): Array[a] =
  if end == len then
    array
  else if end >= tailIndex(len) then
    ArrayImpl(end, startShift, tree, NativeArray.slice(0, bitMask & end, tail))
  else
    let endIdx = tailIndex(end)
    let depth =
      (endIdx - 1)
        |> max(1)
        |> toFloat
        |> logBase(toFloat(branchFactor))
        |> floor
    let newShift = max(5, depth * shiftStep)
    in ArrayImpl
      ( end
      , newShift
      , tree |> sliceTree(startShift, endIdx) |> hoistTree(startShift, newShift)
      , fetchNewTail(startShift, end, endIdx, tree)
      )

def hidden fetchNewTail(shift: Int, end: Int, treeEnd: Int, tree: Tree[a]): NativeArray[a] =
  let pos = bitMask & (treeEnd >>> shift)
  in
    select NativeArray.unsafeGet(pos, tree)
      case SubTree(sub) -> fetchNewTail(shift - shiftStep, end, treeEnd, sub)
      case Leaf(values) -> NativeArray.slice(0, bitMask & end, values)
    end

def hidden sliceTree(shift: Int, endIdx: Int, tree: Tree[a]): Tree[a] =
  let lastPos = bitMask & (endIdx >>> shift)
  in
    select NativeArray.unsafeGet(lastPos, tree)
      case SubTree(sub) ->
        let newSub = sliceTree(shift - shiftStep, endIdx, sub)
        in
          if NativeArray.length(newSub) == 0 then
            NativeArray.slice(0, lastPos, tree)
          else
            tree
              |> NativeArray.slice(0, lastPos + 1)
              |> NativeArray.unsafeSet(lastPos, SubTree(newSub))
      case Leaf(_) -> NativeArray.slice(0, lastPos, tree)
    end

def hidden hoistTree(oldShift: Int, newShift: Int, tree: Tree[a]): Tree[a] =
  if oldShift <= newShift || NativeArray.length(tree) == 0 then
    tree
  else
    select NativeArray.unsafeGet(0, tree)
      case SubTree(sub) -> hoistTree(oldShift - shiftStep, newShift, sub)
      case Leaf(_) -> tree
    end

def hidden sliceLeft(from: Int, (ArrayImpl(len, _, tree, tail) as array): Array[a]): Array[a] =
  if from == 0 then
    array
  else if from >= tailIndex(len) then
    ArrayImpl
      ( len - from
      , shiftStep
      , NativeArray.empty
      , NativeArray.slice(from - tailIndex(len), NativeArray.length(tail), tail)
      )
  else
    let helper(node, acc) =
      select node
        case SubTree(subTree) -> NativeArray.foldr(helper, acc, subTree)
        case Leaf(leaf) -> leaf | acc
      end
    let leafNodes = NativeArray.foldr(helper, [ tail ], tree)
    let skipNodes = from / branchFactor
    let nodesToInsert = List.drop(skipNodes, leafNodes)
    in
      select nodesToInsert
        case [] -> empty
        case head | rest ->
          let firstSlice = from - (skipNodes * branchFactor)
          let initialBuilder =
            { tail = NativeArray.slice(firstSlice, NativeArray.length(head), head)
            , nodeList = []
            , nodeListSize = 0
            }
          in List.foldl(appendHelpBuilder, initialBuilder, rest) |> builderToArray(True)
      end

alias hidden Builder[a] =
    { tail: NativeArray[a]
    , nodeList: List[Node[a]]
    , nodeListSize: Int
    }

def hidden emptyBuilder: Builder[a] =
    { tail = NativeArray.empty
    , nodeList = []
    , nodeListSize = 0
    }

def hidden builderFromArray(ArrayImpl(len, _, tree, tail): Array[a]): Builder[a] =
  let helper(node, acc) =
    select node
      case SubTree(subTree) -> NativeArray.foldl(helper, acc, subTree)
      case Leaf(_) -> node | acc
    end
  in
    { tail = tail
    , nodeList = NativeArray.foldl(helper, [], tree)
    , nodeListSize = len / branchFactor
    }

def hidden builderToArray(reverseNodeList: Bool, builder: Builder[a]): Array[a] =
  if builder.nodeListSize == 0 then
    ArrayImpl(NativeArray.length(builder.tail), shiftStep, NativeArray.empty, builder.tail)
  else
    let treeLen = builder.nodeListSize * branchFactor
    let depth = (treeLen - 1) |> toFloat |> logBase(toFloat(branchFactor)) |> floor
    let correctNodeList =
      if reverseNodeList then
        List.reverse(builder.nodeList)
      else
        builder.nodeList
    let tree = treeFromBuilder(correctNodeList, builder.nodeListSize)
    in
      ArrayImpl
        ( NativeArray.length(builder.tail) + treeLen
        , max(5, depth * shiftStep)
        , tree
        , builder.tail
        )

def hidden treeFromBuilder(nodeList: List[Node[a]], nodeListSize: Int): Tree[a] =
  let newNodeSize = ceil(toFloat(nodeListSize) / toFloat(branchFactor))
  in
    if newNodeSize == 1 then
      NativeArray.initializeFromList(branchFactor, nodeList) |> Tuple.first
    else
      treeFromBuilder(compressNodes(nodeList, []), newNodeSize)

def hidden compressNodes(nodes: List[Node[a]], acc: List[Node[a]]): List[Node[a]] =
  let ( node, remainingNodes ) = NativeArray.initializeFromList(branchFactor, nodes)
  let newAcc = SubTree(node) | acc
  in
    select remainingNodes
      case [] -> List.reverse(newAcc)
      case _ -> compressNodes(remainingNodes, newAcc)
    end
