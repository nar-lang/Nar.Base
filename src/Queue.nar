module Nar.Base.Queue

alias hidden Rear[a] = List[a]

alias hidden Front[a] = List[a]

type Queue[a]
    = QueueImpl(Front[a], Rear[a])

def hidden queue(fl: Front[a], rl: Rear[a]): Queue[a] =
  select fl
    case [] -> QueueImpl(List.reverse(rl), [])
    case _ -> QueueImpl(fl, rl)
  end

def empty: Queue[a] = QueueImpl([], [])

def singleton(a: a): Queue[a] =
  QueueImpl([ a ], [])

def isEmpty(QueueImpl(fl, rl): Queue[a]): Bool =
  List.isEmpty(fl) && List.isEmpty(rl)

def size(QueueImpl(fl, rl): Queue[a]): Int =
  List.length(fl) + List.length(rl)

def enqueue(a: a, QueueImpl(fl, rl): Queue[a]): Queue[a] =
  queue(fl, a | rl)

def dequeue(QueueImpl(fl, rl): Queue[a]): ( Maybe[a], Queue[a] ) =
  select fl
    case [] -> ( Nothing, QueueImpl([], []) )
    case head | tail -> ( Just(head), queue(tail, rl) )
  end
  
def front(QueueImpl(fl, _): Queue[a]): Maybe[a] =
    List.head(fl)

def updateFront(f: (Maybe[a]):Maybe[a], QueueImpl(fl, rl): Queue[a]): Queue[a] =
  let update_(maybe, t) =
    select f(maybe)
      case Just(a) -> a | t
      case Nothing -> t
    end
  in
  select fl
    case h | t -> QueueImpl(update_(Just(h), t), rl)
    case [] -> QueueImpl(update_(Nothing, []), rl)
  end

def fromList(list: List[a]): Queue[a] =
    QueueImpl(list, [])

def toList(QueueImpl(fl, rl): Queue[a]): List[a] =
    fl ++ List.reverse(rl)

def map(fc: (a):b, QueueImpl(fl, rl): Queue[a]): Queue[b] =
  let map_ = List.map(fc)
  in queue(map_(fl), map_(rl))

def filter(fc:(a): Bool, QueueImpl(fl, rl): Queue[a]): Queue[a] = 
  let f = List.filter(fc)
  in queue(f(fl), f(rl))